#!/usr/bin/env python

import sys
import rospy
import numpy as np
from std_msgs.msg import Float64
from std_msgs.msg import Bool
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
from math import fabs
import ball_control

min_dist_ball = 0.6
min_dist_wall = 1

class Navigator():
    def __init__(self):
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        self.delta_angle_sub = rospy.Subscriber('/mybot/delta_angle', Float64, self.delta_angle_callback)
        self.see_red_sub = rospy.Subscriber('/mybot/see_red', Bool, self.see_red_callback)
        self.scan_sub = rospy.Subscriber('/mybot/laser/scan', LaserScan, self.scan_callback)

        self.status = "init"
        self.substatus = "unknown"
        self.delta_angle = None
        self.see_red = False
        self.covered = False
        self.scan = None
        self.view = {
                'right': float('Inf'),
                'fright': float('Inf'),
                'front_narrow': float('Inf'),
                'front': float('Inf'),
                'fleft': float('Inf'),
                'left': float('Inf')
        }
        self.navigate()

    def delta_angle_callback(self, data):
        self.delta_angle = data.data

    def see_red_callback(self, data):
        self.see_red = data.data

    def scan_callback(self, data):
        self.scan = data
        if self.scan is not None:
            self.view['right'] = min(self.scan.ranges[0:144])
            self.view['fright'] = min(self.scan.ranges[145:288])
            self.view["front_narrow"] = min(self.scan.ranges[345:375])
            self.view['front'] = min(self.scan.ranges[288:432])
            self.view['fleft'] = min(self.scan.ranges[423:576])
            self.view['left'] = min(self.scan.ranges[576:720])
            if self.status == "searching":
                self.update_substatus_when_searching()

    def update_substatus_when_searching(self):
        if self.view['fleft'] <= min_dist_wall and self.view['fright'] <= min_dist_wall and self.view['front'] <= min_dist_wall:
            self.change_substatus("turning right")
        elif self.view['fleft'] > min_dist_wall and self.view['fright'] <= min_dist_wall and self.view['front'] <= min_dist_wall:
            self.change_substatus("turning right")
        elif self.view['fleft'] <= min_dist_wall and self.view['fright'] > min_dist_wall and self.view['front'] <= min_dist_wall:
            self.change_substatus("turning right")
        elif self.view['fleft'] <= min_dist_wall and self.view['fright'] <= min_dist_wall and self.view['front'] > min_dist_wall:
            self.change_substatus("forwarding")
        elif self.view['fleft'] <= min_dist_wall and self.view['fright'] > min_dist_wall and self.view['front'] > min_dist_wall:
            self.change_substatus("following")
        elif self.view['fleft'] > min_dist_wall and self.view['fright'] <= min_dist_wall and self.view['front'] > min_dist_wall:
            self.change_substatus("turning right")
        elif self.view['fleft']> min_dist_wall and self.view['fright'] > min_dist_wall and self.view['front'] <= min_dist_wall:
            self.change_substatus("turning right")
        elif self.view['fleft'] > min_dist_wall and self.view['fright'] > min_dist_wall and self.view['front'] > min_dist_wall:
            if self.substatus == "unknown" or self.substatus == "initial forwarding":
                self.change_substatus("initial forwarding")
            else:
                self.change_substatus("forwarding")

    def command_bot(self, lx, ly, lz, ax, ay, az):
        twist = Twist()
        twist.linear.x = lx; twist.linear.y = ly; twist.linear.z = lz
        twist.angular.x = ax; twist.angular.y = ay; twist.angular.z = az
        self.cmd_pub.publish(twist)

    def change_status(self, input_status, info=None):
        if input_status != self.status:
            print "current: ", self.status, "   next: ", input_status
            self.status = input_status

    def change_substatus(self, input_substatus, info=None):
         if input_substatus != self.substatus:
            print "current sub: ", self.substatus, "   next sub: ", input_substatus
            self.substatus = input_substatus

    def init(self):
        if self.covered:
            self.change_status("terminated")
        else:
            self.change_status("searching")

    def search(self):
        if self.see_red:
            print "see red"
            self.change_status("moving_to_red")
        elif self.covered:
            self.change_status("terminated")
        else:
            if self.substatus == "unknown":
                return
            elif self.substatus == "initial forwarding":
                self.initial_forward_search()
            elif self.substatus == "forwarding":
                self.forward_search()
            elif self.substatus == "turning right":
                self.turn_right_search()
            elif self.substatus == "following":
                self.follow_search()
            else:
                print("known sub status under searching")

    def initial_forward_search(self):
        self.command_bot(1, 0, 0, 0, 0, 0)

    def forward_search(self):
        self.command_bot(0.5, 0, 0, 0, 0, 0.5)

    def turn_right_search(self):
        self.command_bot(0, 0, 0, 0, 0, -0.8)

    def follow_search(self):
        self.command_bot(0.5, 0, 0, 0, 0, 0)

    def move_to_red(self):
        if fabs(self.delta_angle) > 5 and self.view["front_narrow"] > min_dist_ball:
            linear = min(0.5, self.view["front_narrow"]*0.2)
            angular = min(0.5, self.delta_angle*0.01)
            self.command_bot(linear, 0, 0, 0, 0, angular)
        elif fabs(self.delta_angle) <= 5 and self.view["front_narrow"] > min_dist_ball:
            linear = min(0.5, self.view["front_narrow"]*0.2)
            angular = 0
            self.command_bot(linear, 0, 0, 0, 0, angular)
        elif fabs(self.delta_angle) > 5 and self.view["front_narrow"] <= min_dist_ball:
            linear = 0
            angular = min(0.5, self.delta_angle*0.01)
            self.command_bot(linear, 0, 0, 0, 0, angular)
        else:
            self.command_bot(0, 0, 0, 0, 0, 0)
            self.change_status("grabbing")

    def grab(self):
        print("lower arm")
        ball_control.lower_arm()
        rospy.sleep(2)
        print("lower slider")
        ball_control.lower_slider()
        print("close holder")
        rospy.sleep(2)
        ball_control.close_holder()
        rospy.sleep(2)
        print("lifting slider")
        ball_control.lift_slider()





    def retrieve(self):
        
        pass

    def move_to_src(self):
        pass

    def terminate(self):
        self.command_bot(0, 0, 0, 0, 0, 0)

    def navigate(self):
        rate = rospy.Rate(200)
        while not rospy.is_shutdown():
            if self.status == "init":
                self.init()
            elif self.status == "searching":
                self.search()
            elif self.status == "moving_to_red":
                self.move_to_red()
            elif self.status == "grabbing":
                self.grab()
            elif self.status == "retrieving":
                self.retrieve()
            elif self.status == "moving_to_src":
                self.moving_to_src()
            elif self.status == "terminated":
                self.terminate()
            else:
                print("unknown status")
            rate.sleep()

def main(args):
    rospy.init_node('navigator', anonymous=True)
    try:
        ball_control.connect()
        ball_control.lift_arm()
        navigator = Navigator()
    except KeyboardInterrupt:
        print("Navigator Shutting down")

if __name__ == '__main__':
    main(sys.argv)